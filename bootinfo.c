#include <stdio.h>
#include <stdint.h>
#include <endian.h>

enum {
    PART_KERNEL = 0,
    PART_RAMDISK,
    PART_RECOVERY,
    PART_LOGO,
    PART_PARAM,
    PART_PRIVATE,
    PART_BAT_MODEL,
    /* recovery private data partition */
    PART_REC_PRIV,
    PART_RESERVED1,
    PART_RESERVED2,
    PART_MAX,
};

typedef uint32_t u32;
typedef uint8_t u8;

#define RECOVERY_PRIV_MAGIC_LEN     (8)
#define RECOVERY_PRIV_MAGIC_NUM     "OnTheGo!"
struct part_info {
    u32 start_sec;
    u32 sec_count;
};

struct bootinfo {
    u32     info_version;           // 1/2/3/4/..
    struct      part_info part[32];     // partition layout, null terminal
    char        uboot_version[64];      // uboot string version
    char        build_variant[16];      // eng/user/oversea/..
    u8      not_signed_check;       // signed check, 0 means check the signature
    u8      board_version;          // defined by ID1-3 GPIO pin
};

// xxd  -i -s $((0x36714)) -l 344 uboot_2 >bootinfo.c
unsigned char _bootinfo[] = {
  0x01, 0x00, 0x00, 0x00, 0xef, 0x04, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00,
  0xef, 0x54, 0x00, 0x00, 0x00, 0x50, 0x00, 0x00, 0xef, 0xa4, 0x00, 0x00,
  0x00, 0xa0, 0x00, 0x00, 0xef, 0x44, 0x01, 0x00, 0x00, 0xa0, 0x00, 0x00,
  0xef, 0xe4, 0x01, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x00, 0x00, 0xef, 0x84, 0x02, 0x00, 0x10, 0x00, 0x00, 0x00,
  0x11, 0x01, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xff, 0x84, 0x02, 0x00,
  0x00, 0xa0, 0x00, 0x00, 0xff, 0x24, 0x03, 0x00, 0x00, 0xa0, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0x2d, 0x42, 0x6f,
  0x6f, 0x74, 0x20, 0x32, 0x30, 0x31, 0x32, 0x2e, 0x30, 0x37, 0x2d, 0x67,
  0x65, 0x64, 0x36, 0x64, 0x32, 0x38, 0x31, 0x20, 0x28, 0x41, 0x70, 0x72,
  0x20, 0x31, 0x31, 0x20, 0x32, 0x30, 0x31, 0x34, 0x29, 0x20, 0x66, 0x6f,
  0x72, 0x20, 0x4d, 0x33, 0x35, 0x58, 0x2d, 0x57, 0x20, 0x72, 0x65, 0x6c,
  0x65, 0x61, 0x73, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x75, 0x73, 0x65, 0x72, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
unsigned int _bootinfo_len = 344;

int main()
{
	struct bootinfo *b = (struct bootinfo *)_bootinfo;
	int i;

	fprintf(stdout, "info_version: %d\n", le32toh(b->info_version));
	fprintf(stdout, "uboot_version: %s\n", le32toh(b->uboot_version));
	fprintf(stdout, "build_variant: %s\n", le32toh(b->build_variant));
	fprintf(stdout, "not_signed_check: %d\n", b->not_signed_check);
	fprintf(stdout, "board_version: %d\n", b->board_version);
	for (i = 0; i < PART_MAX; i++) {
		struct part_info *p = &le32toh(b->part[i]);

		fprintf(stdout, "part %2d: start_sec: %9d (%8x), sec_count: %9d (%8x)\n",
                i, le32toh(p->start_sec), le32toh(p->start_sec),
                le32toh(p->sec_count), le32toh(p->sec_count));
	}

	fprintf(stdout, "\n");
	for (i = 0; i < PART_MAX; i++) {
		struct part_info *p = &le32toh(b->part[i]);

		fprintf(stdout, "part %2d: byte_offset: %9d (%8x), byte_count: %9d (%8x)\n",
				i, le32toh(p->start_sec) * 512, le32toh(p->start_sec) * 512,
				le32toh(p->sec_count) * 512, le32toh(p->sec_count) * 512);
	}
	return 0;
}
